# A first look at using the Black Scholes model to price real options from live market data for a stock of choice. When ran you will see a visualisation
# of what the real option price is in comparison to the Theoretical one from our model.

import yfinance as yf
import math
from sklearn.metrics import mean_squared_error, mean_absolute_error, root_mean_squared_error
import numpy as np
import matplotlib.pyplot as plt
from datetime import datetime

import os
os.system('cls')

stock = "PLTR"

today_str = datetime.now().strftime('%Y-%m-%d')
data = yf.download(stock, start="2022-01-01", end=today_str, interval="1d")
data['log_returns'] = np.log(data['Close'] / data['Close'].shift(1))
DailyVolatility = data['log_returns'].tail(252).std()

Maturity = 0.25 # which is 3 months in terms of years
r = 0.05 # roughly 5% interest rate in US

sigma = math.sqrt(252) * DailyVolatility
s = float(data['Close'].iloc[-1])
k = s

def OptionPrice(s, k, t, r, sig):

    def N(i):
        return (0.5 * (1 + math.erf(i / math.sqrt(2))))

    d1 = (math.log(s/k) + (r + (sig**2)/2)*t) / (sig*math.sqrt(t))
    d2 = d1 - sig*math.sqrt(t)

    price = (s * N(d1)) - (k * math.exp(-r * t) * N(d2))
    
    return price


Price = OptionPrice(s, k, Maturity, r, sigma)
print("-------------------")
print(Price)
print("-------------------")


ticker = yf.Ticker(stock)

ExpiryDates = ticker.options
#print(f"Available expiration dates: {ExpiryDates}")
First = ExpiryDates[7]

FullChain = ticker.option_chain(First)
calls = FullChain.calls
print(calls)

ExpiryTime = datetime.strptime(First, '%Y-%m-%d')
DaysTillExpired = (ExpiryTime - datetime.now()).days
TimeInMarket = DaysTillExpired / 365.0 # to get into years

ModelPrices = []
MarketPrices = []
Strikes = []

for index, row in calls.iterrows(): # go through market data
    StrikePrice = row['strike']
    MarketPrice = (row['bid'] + row['ask']) / 2 if (row['bid'] > 0 and row['ask'] > 0) else row['lastPrice']

    PersonalOptionPrice = OptionPrice(s, StrikePrice, TimeInMarket, r, sigma)
    
    # store results in arr
    Strikes.append(StrikePrice)
    MarketPrices.append(MarketPrice)
    ModelPrices.append(PersonalOptionPrice)

# plot results
plt.figure(figsize=(12, 7))
plt.plot(Strikes, MarketPrices, 'o-', label='Market Prices')
plt.plot(Strikes, ModelPrices, 'x-', label='Black-Scholes Prices')

plt.xlabel("Strike Price (K)")
plt.ylabel("Call Option Price")
plt.title(f"Market Price vs. Black-Scholes Model for {stock} (Expiry: {First})")
plt.legend()
plt.grid(True)

rmse = root_mean_squared_error(MarketPrices, ModelPrices)
mae = mean_absolute_error(MarketPrices, ModelPrices)
mape = np.mean(np.abs((np.array(MarketPrices) - np.array(ModelPrices)) / np.array(MarketPrices))) * 100  # % error percent

print(f"RMSE: {rmse:.2f}")
print(f"MAE: {mae:.2f}")
print(f"MAPE: {mape:.2f}%")
info_text = f"RMSE: {rmse:.2f}\nMAE: {mae:.2f}\nMAPE: {mape:.2f}%"
plt.text(0.05, 0.95, info_text, transform=plt.gca().transAxes, fontsize=12, verticalalignment='top', bbox=dict(boxstyle='round,pad=0.5', fc='wheat', alpha=0.5))

plt.show()
